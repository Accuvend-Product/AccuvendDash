import React from "react";
import TokenGenerated from "../icons/token-generated";
import MeterValidated from "../icons/meter-validated";
import Replay from "../icons/replay";
import DiscoUp from "../icons/Disco-up";
import PaymentConfirmed from "../icons/payment-confirmed";
import { Check, PlayCircle } from "lucide-react";
import * as EventConstant from "./constants";
import { getDateTimeString } from "../../lib/utils";

export const EventTimeline = ({events , originalRow , showInfo}) => {
//   const events = props.events;
//   const originalRow = props.data;
  const ListOfEvents = [
    {
      title: (
        <span>
          Meter Validated by <br /> {originalRow?.superagent}
        </span>
      ),
      Icon: (props) => <MeterValidated {...props} />,
      eventType: "METER_VALIDATED",
      items_in_category: [
        EventConstant.METER_VALIDATION_SENT_PARTNER,
        EventConstant.METER_VALIDATION_RECIEVED_FROM_VENDOR,
        EventConstant.METER_VALIDATION_REQUEST_SENT_TO_VENDOR,
      ],
      triggerEvents: [
        EventConstant.METER_VALIDATION_SENT_PARTNER,
        EventConstant.METER_VALIDATION_RECIEVED_FROM_VENDOR,
        EventConstant.METER_VALIDATION_REQUEST_SENT_TO_VENDOR,
      ],
    },
    {
      title: (
        <span>
          Disco up checked by <br /> {originalRow?.superagent}
        </span>
      ),
      eventType: "DISCO_UP",
      Icon: (props) => <DiscoUp {...props} />,
      items_in_category: [
        EventConstant.CHECK_DISCO_UP_INITIATED_TO_VENDOR,
        EventConstant.CHECK_DISCO_UP_CONFIRMED_FROM_VENDOR,
      ],
      triggerEvents:  [
        EventConstant.CHECK_DISCO_UP_INITIATED_TO_VENDOR,
        EventConstant.CHECK_DISCO_UP_CONFIRMED_FROM_VENDOR,
      ]
    },
    {
      title: (
        <span>
          Payment Confirmed by <br /> {originalRow?.partnerName}
        </span>
      ),
      eventType: EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
      items_in_category: [
        EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER,
      ],
      triggerEvents: [
        EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER,
      ],
      Icon: (props) => <PaymentConfirmed {...props} />
    },
    {
      title: (
        <span>
          Token Generated by <br /> {originalRow?.superagent}
        </span>
      ),
      eventType: `TOKEN_GENERATED`,
      items_in_category: [
        EventConstant.TOKEN_RECIEVED_FROM_VENDOR,
        EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
        EventConstant.TOKEN_REQUEST_FAILED,
        EventConstant.TOKEN_REQUEST_TIMEDOUT,
        EventConstant.TOKEN_REQUEST_SUCCESS_WITH_NO_TOKEN,
        EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER_REQUERY,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_INITIATED,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_RETRY,
        EventConstant.GET_TRANSACTION_TOKEN_REQUESTED_FROM_VENDOR,
        EventConstant.RETRY_PURCHASE_FROM_NEW_VENDOR,
      ],
      triggerEvents:[
        EventConstant.TOKEN_RECIEVED_FROM_VENDOR,
        EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
        // EventConstant.GET_TRANSACTION_TOKEN_REQUESTED_FROM_VENDOR,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_INITIATED,
      ],
      Icon : (props) => <TokenGenerated {...props} />
    },
    {
      title: (
        <span>
          Token Sent to <br /> {originalRow?.partnerName}
        </span>
      ),
      eventType: "TOKEN_SENT",
      items_in_category: [
        EventConstant.TOKEN_SENT_TO_PARTNER,
        EventConstant.TOKEN_SENT_TO_PARTNER_RETRY,
        EventConstant.TOKEN_SENT_TO_EMAIL,
        EventConstant.TOKEN_SENT_TO_NUMBER,
        EventConstant.WEBHOOK_NOTIFICATION_SENT_TO_PARTNER,
        EventConstant.WEBHOOK_NOTIFICATION_CONFIRMED_FROM_PARTNER,
        EventConstant.WEBHOOK_NOTIFICATION_TO_PARTNER_RETRY,
      ],
      triggerEvents:[
        EventConstant.TOKEN_SENT_TO_PARTNER,
        EventConstant.TOKEN_SENT_TO_EMAIL,
        // EventConstant.TOKEN_SENT_TO_NUMBER,
      ],
      Icon: (props) => <Check {...props} />,
    },
  ];

  return (
    <div className="flex mb-6 items-start">
      <ol className="flex justify-between items-start w-full">
        {" "}
        {ListOfEvents?.map((eventItem, index) => {
          const status_color = {
            PENDING: "bg-gray-200",
            COMPLETE: "bg-green-500",
            FAILED: "bg-red-500",
          };
         
          let currentStatus = "PENDING"
          if(index === 1){
            // Done Because No Disco UP events Yet 
            currentStatus = ListOfEvents[0].triggerEvents.every((item) => {
              return events.findIndex(_item => _item?.eventType === item)  !== -1 
            }) ? "COMPLETE" : "PENDING";
          
          }else {
            currentStatus = eventItem?.triggerEvents.every((item) => {
              return events.findIndex(_item => _item?.eventType === item)  !== -1 
            }) ? "COMPLETE" : "PENDING";
          }
           


          return (
            <li className="relative w-full">
              <div className="flex items-center">
                {
                  <div
                    className={`flex items-center justify-center p-3 w-12 h-12 ${
                      status_color[currentStatus] || "bg-gray-200"
                    } rounded-full ring-0 ring-white `}
                  >
                    {eventItem?.Icon({className : `text-white`})}
                  </div>
                }
                {eventItem?.eventType !==
                  "TOKEN_SENT" && (
                  <div className="flex w-full bg-gray-200 h-0.5 border-dashed border-t-2 border-gray-400"></div>
                )}
              </div>
              <div className="mt-3">
                <h3 className="font-medium text-gray-900 text ">
                  {eventItem?.title}
                </h3>
              </div>
             { showInfo && <div className="mt-5">
                <ol class="relative border-s border-gray-200">
                 
                  {events.sort((a, b) => new Date(a?.createdAt) - new Date(b?.createdAt))
                    ?.filter((ele) =>
                      eventItem?.items_in_category?.includes(ele?.eventText)
                    )
                    ?.map((eventData) => {
                      return (
                        <li class="ms-4 mb-6 me-5">
                          <div class="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -start-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
                          <time class="mb-1 text-xs font-normal leading-none text-gray-400 dark:text-gray-500">
                            {getDateTimeString(eventData?.eventTimestamp)}
                          </time>
                          <h3 class="text-sm font-semibold text-gray-900 dark:text-white">
                            {eventData?.eventText
                              ?.split("_")
                              .map(
                                (word) =>
                                  word.charAt(0).toUpperCase() + word.slice(1)
                              )
                              .join(" ")}
                          </h3>
                          <p class="text-sm font-normal text-gray-500 dark:text-gray-400">
                            source : {eventData?.source}
                          </p>
                        </li>
                      );
                    })}
                </ol>
              </div>}
            </li>
          );
        })}
      </ol>
      {/* <div className="flex items-center gap-x-7  ">
              <button type="button" className="text-sm cursor-pointer hover:bg-blue-900 bg-blue-800 py-3 px-3 text-white rounded-md">
                  Create Ticket
              </button>
              <button type="button" className="w-10 h-10 text-green-500 hover:text-green-800 cursor-pointer">
                  <PlayCircle strokeWidth={1.5} className="w-full h-full" />
              </button>
            </div> */}
    </div>
  );
};
