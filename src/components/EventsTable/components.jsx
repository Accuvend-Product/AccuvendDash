import React from "react";
import TokenGenerated from "../icons/token-generated";
import MeterValidated from "../icons/meter-validated";
import Replay from "../icons/replay";
import DiscoUp from "../icons/Disco-up";
import PaymentConfirmed from "../icons/payment-confirmed";
import { Check, PlayCircle } from "lucide-react";
import * as EventConstant from "./constants";
import { calculateDuration, getDateTimeString } from "../../lib/utils";

export const EventTimeline = ({ events, originalRow, showInfo }) => {
  //   const events = props.events;
  //   const originalRow = props.data;
  const ListOfEvents = [
    {
      title: (
        <span>
          Meter Validated by <br /> {originalRow?.superagent}
        </span>
      ),
      Icon: (props) => <MeterValidated {...props} />,
      eventType: "METER_VALIDATED",
      items_in_category: [
        EventConstant.METER_VALIDATION_SENT_PARTNER,
        EventConstant.METER_VALIDATION_RECIEVED_FROM_VENDOR,
        EventConstant.METER_VALIDATION_REQUEST_SENT_TO_VENDOR,
      ],
      triggerEvents: [
        EventConstant.METER_VALIDATION_SENT_PARTNER,
        EventConstant.METER_VALIDATION_RECIEVED_FROM_VENDOR,
        EventConstant.METER_VALIDATION_REQUEST_SENT_TO_VENDOR,
      ],
    },
    // {
    //   title: (
    //     <span>
    //       Disco up checked by <br /> {originalRow?.superagent}
    //     </span>
    //   ),
    //   eventType: "DISCO_UP",
    //   Icon: (props) => <DiscoUp {...props} />,
    //   items_in_category: [
    //     EventConstant.CHECK_DISCO_UP_INITIATED_TO_VENDOR,
    //     EventConstant.CHECK_DISCO_UP_CONFIRMED_FROM_VENDOR,
    //   ],
    //   triggerEvents: [
    //     EventConstant.CHECK_DISCO_UP_INITIATED_TO_VENDOR,
    //     EventConstant.CHECK_DISCO_UP_CONFIRMED_FROM_VENDOR,
    //   ],
    // },
    {
      title: (
        <span>
          Payment Confirmed by <br /> {originalRow?.partnerName}
        </span>
      ),
      eventType: EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
      items_in_category: [EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER],
      triggerEvents: [EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER],
      Icon: (props) => <PaymentConfirmed {...props} />,
    },
    {
      title: (
        <span>
          Token Generated by <br /> {originalRow?.superagent}
        </span>
      ),
      eventType: `TOKEN_GENERATED`,
      items_in_category: [
        EventConstant.TOKEN_RECIEVED_FROM_VENDOR,
        EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
        EventConstant.TOKEN_REQUEST_FAILED,
        EventConstant.TOKEN_REQUEST_TIMEDOUT,
        EventConstant.TOKEN_REQUEST_SUCCESS_WITH_NO_TOKEN,
        EventConstant.POWER_PURCHASE_INITIATED_BY_CUSTOMER_REQUERY,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_INITIATED,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_RETRY,
        EventConstant.GET_TRANSACTION_TOKEN_REQUESTED_FROM_VENDOR,
        EventConstant.RETRY_PURCHASE_FROM_NEW_VENDOR,
      ],
      triggerEvents: [
        EventConstant.TOKEN_RECIEVED_FROM_VENDOR,
        EventConstant.VEND_ELECTRICITY_REQUESTED_FROM_VENDOR,
        // EventConstant.GET_TRANSACTION_TOKEN_REQUESTED_FROM_VENDOR,
        EventConstant.GET_TRANSACTION_TOKEN_FROM_VENDOR_INITIATED,
      ],
      Icon: (props) => <TokenGenerated {...props} />,
    },
    {
      title: (
        <span>
          Token Sent to <br /> {originalRow?.partnerName}
        </span>
      ),
      eventType: "TOKEN_SENT",
      items_in_category: [
        EventConstant.TOKEN_SENT_TO_PARTNER,
        EventConstant.TOKEN_SENT_TO_PARTNER_RETRY,
        EventConstant.TOKEN_SENT_TO_EMAIL,
        EventConstant.TOKEN_SENT_TO_NUMBER,
        EventConstant.WEBHOOK_NOTIFICATION_SENT_TO_PARTNER,
        EventConstant.WEBHOOK_NOTIFICATION_CONFIRMED_FROM_PARTNER,
        EventConstant.WEBHOOK_NOTIFICATION_TO_PARTNER_RETRY,
      ],
      triggerEvents: [
        EventConstant.TOKEN_SENT_TO_PARTNER,
        EventConstant.TOKEN_SENT_TO_EMAIL,
        EventConstant.TOKEN_SENT_TO_NUMBER,
      ],
      Icon: (props) => <Check {...props} />,
    },
  ];

  return (
    <div className="flex mb-6 items-start">
      <ol className="flex justify-between items-start w-full">
        {" "}
        {ListOfEvents?.map((eventItem, index) => {
          const status_color = {
            PENDING: "bg-gray-200",
            COMPLETE: "bg-green-500",
            FAILED: "bg-red-500",
          };

          let currentStatus = "PENDING";
          if (index === 1) {
            // Done Because No Disco UP events Yet
            currentStatus = ListOfEvents[0].triggerEvents.every((item) => {
              return (
                events.findIndex((_item) => _item?.eventType === item) !== -1
              );
            })
              ? "COMPLETE"
              : "PENDING";
          } else {
            currentStatus = eventItem?.triggerEvents.every((item) => {
              return (
                events.findIndex((_item) => _item?.eventType === item) !== -1
              );
            })
              ? "COMPLETE"
              : "PENDING";
          }

          return (
            <li className="relative w-full">
              <div className="flex items-center">
                {
                  <div
                    className={`flex items-center justify-center p-3 w-12 h-12 ${
                      status_color[currentStatus] || "bg-gray-200"
                    } rounded-full ring-0 ring-white `}
                  >
                    {eventItem?.Icon({ className: `text-white` })}
                  </div>
                }
                {eventItem?.eventType !== "TOKEN_SENT" && (
                  <div className="flex w-full bg-gray-200 h-0.5 border-dashed border-t-2 border-gray-400"></div>
                )}
              </div>
              <div className="mt-3">
                <h3 className="font-medium text-gray-900 text ">
                  {eventItem?.title}
                </h3>
              </div>
              {showInfo && (
                <EventSubTimeline events={events} partnerName={originalRow?.partnerName} eventItem={eventItem} />
              )}
            </li>
          );
        })}
      </ol>
    </div>
  );
};

const EventSubTimeline = ({ events, eventItem , partnerName }) => {
  const subEvents = events
    .sort((a, b) => new Date(a?.createdAt) - new Date(b?.createdAt))
    ?.filter((ele) => eventItem?.items_in_category?.includes(ele?.eventText));

  const eventSuccessIndexObject = eventCountData(subEvents);
  let Duration = "0 secs"
  if(subEvents.length > 0 ) Duration = calculateDuration(subEvents[0].createdAt, subEvents[subEvents.length - 1].createdAt)
  return (
    <>
      <time className="mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500">Duration: {Duration}</time>
      <div className="mt-5">
        <ol className="relative border-s border-gray-200">
          {subEvents?.map((eventData, index) => {
            const eventSuccess =
              eventSuccessIndexObject[eventData.eventText] === index;
            const payload = JSON.parse(eventData?.payload || "{}");
            const superagent = eventData?.eventText === "RETRY_PURCHASE_FROM_NEW_VENDOR" ?  payload?.newSuperAgent : payload?.superagent
            return (
              <li className="ms-4 mb-6 me-5">
                <div className="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -start-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
                <time className="mb-1 text-xs font-normal leading-none text-gray-400 dark:text-gray-500">
                  {getDateTimeString(eventData?.eventTimestamp)}
                </time>
                {/* <h3
                  className={`text-sm font-semibold  ${
                    eventSuccess ? "text-green-900 " : "text-red-900"
                  } `}
                >
                  {
                    parseVendorPartnerName(
                      EventConstant.eventsObjectHeadingsDscription[
                        eventData?.eventText
                      ]?.heading,
                      superagent,
                      partnerName
                    )
                  }
                </h3> */}
                <p
                  className={`text-sm font-normal ${
                    eventSuccess ? "text-green-500 " : "text-red-500"
                  }`}
                >
                  {parseVendorPartnerName(
                    eventSuccess
                      ? EventConstant.eventsObjectHeadingsDscription[
                          eventData?.eventText
                        ]?.heading
                      : EventConstant.eventsObjectHeadingsDscription[
                          eventData?.eventText
                        ]?.failedStateDescription,
                        superagent,
                        partnerName
                  )}
                </p>
              </li>
            );
          })}
        </ol>
      </div>
    </>
  );
};

/**
 * Returns an object containing the last index where each unique event occurs in the timeline.
 * An event is considered failed if it occurs more than once or is not the latest occurrence.
 *
 * @param {Array} events - The list of grouped events.
 * @returns {Object} - An object where keys are unique event texts, and values are the last index of their occurrence.
 */
function eventCountData(events) {
  const eventStateObject = {};

  for (let i = 0; i < events.length; i++) {
    // Use eventText as the key and store the last index of its occurrence
    eventStateObject[events[i]?.eventText] = i;
  }

  return eventStateObject;
}

/**
 * Replaces placeholders (%vendor% and %partner%) in the given text with actual vendor and partner names.
 *
 * @param {string} text - The input text containing placeholders.
 * @param {string} vendor - The actual vendor name to replace %vendor%.
 * @param {string} partner - The actual partner name to replace %partner%.
 * @returns {string} - The text with replaced vendor and partner names.
 */

function parseVendorPartnerName(text, vendor, partner) {
  // Replace %vendor% with the actual vendor name
  const textWithVendor = text.replace(/%vendor%/gi, vendor);

  // Replace %partner% with the actual partner name
  const textWithPartner = textWithVendor.replace(/%partner%/gi, partner);

  return textWithPartner;
}
